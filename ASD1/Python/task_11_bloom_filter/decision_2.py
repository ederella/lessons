from task_11_bloom_filter.decision import BloomFilter
"""2.* На практике часто применяется сложение/слияние фильтров Блюма: в пиринговых сетях или распределённых базах данных,
где на каждом узле ведутся локальные фильтры Блюма для проверки элементов (нередко в архитектуре MapReduce).
 Важная задача -- слияние этих локальных фильтров, чтобы любой узел мог эффективно проверять наличие элемента
 без необходимости обращаться к каждому отдельному фильтру.
 Напишите алгоритм слияния нескольких фильтров Блюма (одинакового размера и с одинаковым набором хэш-функций).
Как изменится вероятность ложного срабатывания для итогового фильтра?

 Ответ: Вероятность ложного срабатывания увеличится, если количество элементов на входе увеличится:
 было P = 0,6931^(m / n), станет P = 0,6931^(m / n * size)
"""
class MergedBloomFilter(BloomFilter):
    def __init__(self, filters: list):
        super().__init__(filters[0])
        self.filters = filters
        self.bitarr = 0b0
        for f in filters:
            self.bitarr |=f.bitarr

"""
3.* Реализуйте фильтр Блюма, предусматривающий удаление элементов (стандартный фильтр Блюма удаление не поддерживает).
Учтите, что при удалении несуществующих элементов (с ложноположительным результатом проверки их наличия)
структура фильтра нарушается и могут удаляться другие входные значения.

"""
class BloomFilterWithDelete:

    def __init__(self, f_len):
        self.filter_len = f_len
        self.counts = [int] * f_len

    def hash1(self, str1):
        res = 0
        for c in str1:
            res = res * 17 + ord(c)
        return res% self.filter_len

    def hash2(self, str1):
        res = 0
        for c in str1:
            res = res * 223 + ord(c)
        return res% self.filter_len

    def add(self, str1):
        h1 = self.hash1(str1)
        h2 = self.hash2(str1)
        self.counts[h1] +=1
        self.counts[h2] += 1


    def is_value(self, str1):
        h1 = self.hash1(str1)
        h2 = self.hash2(str1)
        if self.counts[h1] == 0 or self.counts[h2] == 0:
            return False
        return True

    def delete(self, str1) :
        h1 = self.hash1(str1)
        h2 = self.hash2(str1)
        if self.counts[h1] > 0 and self.counts[h2] > 0:
            self.counts[h1] -= 1
            self.counts[h2] -= 1


"""
4.* Подумайте (и попробуйте реализовать), каким может быть алгоритм, который анализирует конфигурацию фильтра
Блюма и пытается, насколько возможно, восстановить исходное множество с учётом всех ограничений и искажений
(например, коллизий, ложноположительных срабатываний...).
Под исходным множеством понимаются исходные данные, оригинальное множество элементов, которые были добавлены в фильтр Блюма через метод Add.

 - Честно говоря, не смогла придумать ничего, что можно было бы показать.
 Вероятно, это еще можно вычислить, если есть ограниченное и заранее известное количество добавляемых значений, 
 причем таких, чтобы не образовывались коллизии. В общем, хотела бы посмотреть рекомендации.

"""


"""Рефлексия по решению задач задания 9.

5. Словарь с использованием упорядоченного списка по ключу.
 - Выполнено, как в рекомендации, но я, признаюсь, запомнила этот момент, когда проходила курс на Java
 """

