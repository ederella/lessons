from task_10_power_set.decision import PowerSet
"""Рефлексия по решению задач предыдущих заданий.

10. Множество.

4. Метод, реализующий декартово произведение множеств.

Алгоритм декартова произведения множеств A и B:
- Создаём пустой результирующий список (множество)
- Для каждого элемента x из множества A:
- Для каждого элемента y из второго множества B:
-- Создаём упорядоченную пару (x, y)
-- Добавляем эту пару в результирующий список
- Возвращаем результирующий список
Этот метод можно рекурсивно обобщить на произвольное количество перемножаемых множеств:
Базовый случай:
Если передан только один список/множество, возвращаем список кортежей с единственным элементом
Если списков нет, возвращаем пустой список

Рекурсивный случай:
Вызываем рекурсивный метод для всех множеств, кроме первого
Получаем один результат рекурсивного вызова (декартово произведение оставшихся множеств)
Для каждого элемента первого множества:
- Для каждого кортежа из результата рекурсивного вызова
- Создаём новый кортеж, добавляя элемент первого множества в начало

Я сделала только для 2х множеств.
Вот реализация для любого количества:
"""

def cartesian_product(sets: list[PowerSet]) -> PowerSet:
    if len(sets) == 0:
        return []
    if len(sets) == 1:
        return [(item,) for item in sets[0].get_storage()]
    tuples = cartesian_product(sets[1:])
    res = []
    for el in sets[0].get_storage():
        for t in tuples:
            res.append((el,) + t)
    return res


"""
6. Реализуйте мульти-множество (Bag), в котором каждый элемент может присутствовать несколько раз.

Ключевая идея: использовать хэш-таблицу не как множество, а как словарь с подсчётом вхождений элементов.

1. Хранение частот:
Обычное множество: Каждый элемент присутствует только один раз
Мультимножество: Для каждого элемента хранится счетчик количества вхождений

2. Механизм добавления:
Обычное множество: При добавлении дубликата множество не изменяется
Мультимножество: При добавлении существующего элемента увеличивается его счетчик

3. Механизм удаления:
Обычное множество: Полное удаление элемента
Мультимножество: Уменьшение счетчика, полное удаление только при счетчике = 0

4. Дополнительные операции:
Обычное множество: Базовые операции принадлежности
Мультимножество: Возможность получения частоты каждого элемента

Я сделала через обычный список, вот реализация через хэш-таблицу
"""

class Bag:
    def __init__(self, sz):
        self.size = sz
        self.values = [None] * self.size
        self.counts = [None] * self.size

    def hash_fun(self, value):
        return len(value.encode()) % self.size

    def exists(self, values):
       return values in self.values

    def put(self, value):
        idx = self.get_index(value)
        if idx is not None:
            self.counts[idx] += 1

        slot_idx = self.hash_fun(value)
        while self.values[slot_idx] is not None and self.values[slot_idx] != value:
            slot_idx = (slot_idx + 1) % self.size
        self.values[slot_idx] = value

    def get_index(self, value):
        slot_idx = self.hash_fun(value)
        if self.values[slot_idx] == value:
            return slot_idx
        i = (slot_idx + 1)%self.size
        while i != slot_idx:
            if self.values[i] == value:
                return i
            i = (i + 1) % self.size
        return None

    def delete(self, value):
        idx = self.get_index(value)
        if idx is not None:
            if self.counts[idx] > 1:
                self.counts[idx] -= 1
            else:
                self.counts[idx] = 0
                self.values[idx] = None

    def get_count(self, value):
        idx = self.get_index(value)
        if idx is not None:
            return self.counts[idx]
        else:
            return 0

"""
11. Фильтр Блюма.

2. Алгоритм слияния нескольких фильтров Блюма.
- В целом выполнено верно - слияние через "или" и указала верно, что вероятность ложного срабатывания увеличится

3. Фильтр Блюма, предусматривающий удаление элементов.
Тут применяются флэт-фильтры или счётные фильтры Блюма, которые были разработаны для поддержки безопасных операций удаления. 
Эти структуры данных используют дополнительные механизмы, 
такие как счётчики, чтобы отслеживать количество добавлений для каждого бита, позволяя корректно удалять элементы.
 - Сделала через фильтр Блума со счетчиком

4. Алгоритм, который анализирует конфигурацию фильтра Блюма и пытается, насколько возможно, восстановить исходное множество с учётом всех ограничений и искажений (например, коллизий, ложноположительных срабатываний...).

Хорошее решение, кроме брут-форса, вряд ли возможно, особенно если хэш-функции качественные.
Прежде всего изучаем "предметную область" входных данных, тематические словари, 
может история имеется, итерациями делаем, стараясь избегать ложноположительных срабатываний, 
какие-нибудь метрики "схожести" данных используем, байесовскую аппроксимацию и т.п.

 - Я вариант с брут-форсом как-то сразу отмела, вероятно стоило его попробовать. Но в целом ясно, что готового рецепта на этот случай нет:)
"""
